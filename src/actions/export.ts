"use server";

import { headers } from "next/headers";
import { auth } from "~/lib/auth";
import { db } from "~/server/db";
import { getVoiceById } from "~/lib/voices";
import { escapeXml, escapeJavaScript, escapePython } from "~/lib/sanitize";

export type ExportFormat = "twiml" | "studio-json" | "node-snippet" | "python-snippet";

interface ExportResult {
  success: boolean;
  content?: string;
  error?: string;
}

// Using escapeXml from sanitize.ts

/**
 * Generate TwiML XML for a project
 */
function generateTwiML(text: string, voiceId?: string, language?: string): string {
  const voiceAttr = voiceId ? ` voice="${escapeXml(voiceId)}"` : "";
  const langAttr = language ? ` language="${escapeXml(language)}"` : "";
  const escapedText = escapeXml(text);

  return `<?xml version="1.0" encoding="UTF-8"?>
<!-- TwiML Voice Configuration -->
<!-- Use this in your Twilio webhook response -->
<Response>
  <Say${voiceAttr}${langAttr}>
    ${escapedText}
  </Say>
</Response>

<!-- Example with additional options -->
<!--
<Response>
  <Say${voiceAttr}${langAttr}>
    ${escapedText}
  </Say>
  <Pause length="2"/>
  <Say${voiceAttr}${langAttr}>
    Additional message here
  </Say>
</Response>
-->`;
}

/**
 * Generate Twilio Studio Flow JSON
 */
function generateStudioJSON(text: string, voiceId?: string, language?: string): string {
  const studioFlow = {
    description: "Generated by Doppel Talk",
    states: [
      {
        name: "trigger",
        type: "trigger",
        transitions: [
          {
            event: "incomingMessage",
            next: "say_widget",
          },
        ],
      },
      {
        name: "say_widget",
        type: "say-play",
        properties: {
          say: text,
          ...(voiceId && { voice: voiceId }),
          ...(language && { language: language }),
          loop: 1,
        },
        transitions: [
          {
            event: "audioComplete",
            next: "end",
          },
        ],
      },
      {
        name: "end",
        type: "end",
      },
    ],
    initial_state: "trigger",
  };

  return JSON.stringify(studioFlow, null, 2);
}

/**
 * Generate Node.js code snippet
 */
function generateNodeSnippet(text: string, voiceId?: string, language?: string): string {
  const voiceConfig = voiceId ? `voice: "${escapeJavaScript(voiceId)}",` : "";
  const langConfig = language ? `language: "${escapeJavaScript(language)}",` : "";
  const escapedText = escapeJavaScript(text);

  return `// Twilio Voice Configuration - Node.js
// Install: npm install twilio

const twilio = require('twilio');

// Your Twilio credentials
const accountSid = 'ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';
const authToken = 'your-auth-token';

const client = twilio(accountSid, authToken);

// Generate TwiML response
app.post('/voice', (req, res) => {
  const twiml = new twilio.twiml.VoiceResponse();
  
  twiml.say({
    ${voiceConfig}
    ${langConfig}
  }, \`${escapedText}\`);
  
  res.type('text/xml');
  res.send(twiml.toString());
});

// Or use TwiML directly
const twiml = \`<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say${voiceId ? ` voice="${voiceId}"` : ""}${language ? ` language="${language}"` : ""}>
    ${escapedText}
  </Say>
</Response>\`;

res.type('text/xml');
res.send(twiml);`;
}

/**
 * Generate Python code snippet
 */
function generatePythonSnippet(text: string, voiceId?: string, language?: string): string {
  const voiceConfig = voiceId ? `voice="${escapePython(voiceId)}",` : "";
  const langConfig = language ? `language="${escapePython(language)}",` : "";
  const escapedText = escapePython(text);

  const voiceAttr = voiceId ? ` voice="${voiceId}"` : "";
  const langAttr = language ? ` language="${language}"` : "";

  return `# Twilio Voice Configuration - Python
# Install: pip install twilio

from twilio.twiml.voice_response import VoiceResponse, Say

# Your Twilio credentials
account_sid = 'ACxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
auth_token = 'your-auth-token'

# Generate TwiML response (Flask example)
from flask import Flask, Response

app = Flask(__name__)

@app.route('/voice', methods=['POST'])
def voice():
    response = VoiceResponse()
    response.say(
        "${escapedText}",
        ${voiceConfig}
        ${langConfig}
    )
    
    return Response(str(response), mimetype='text/xml')

# Or use TwiML directly
twiml = f'''<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say${voiceAttr}${langAttr}>
    ${escapedText}
  </Say>
</Response>'''`;
}

/**
 * Export project in specified format
 */
export async function exportProject(
  projectId: string,
  format: ExportFormat,
): Promise<ExportResult> {
  try {
    const session = await auth.api.getSession({
      headers: await headers(),
    });

    if (!session?.user?.id) {
      return { success: false, error: "Unauthorized" };
    }

    // Fetch project from database
    const project = await db.audioProject.findUnique({
      where: { id: projectId },
    });

    if (!project) {
      return { success: false, error: "Project not found" };
    }

    if (project.userId !== session.user.id) {
      return { success: false, error: "Unauthorized" };
    }

    // Get voice information from project (now stored in v2 schema)
    const voiceId = project.voiceId || undefined;
    const language = project.language;
    
    // Update export count and timestamp
    await db.audioProject.update({
      where: { id: projectId },
      data: {
        exportCount: { increment: 1 },
        lastExportedAt: new Date(),
      },
    });

    // For projects created with Twilio/Polly, we'd need to store voiceId
    // For now, we'll generate exports without specific voice IDs for Chatterbox projects
    // Users can manually edit the exported code to add their voice

    let content: string;

    switch (format) {
      case "twiml":
        content = generateTwiML(project.text, voiceId, language);
        break;
      case "studio-json":
        content = generateStudioJSON(project.text, voiceId, language);
        break;
      case "node-snippet":
        content = generateNodeSnippet(project.text, voiceId, language);
        break;
      case "python-snippet":
        content = generatePythonSnippet(project.text, voiceId, language);
        break;
      default:
        return { success: false, error: "Invalid export format" };
    }

    return {
      success: true,
      content,
    };
  } catch (error) {
    console.error("Export error:", error);
    return {
      success: false,
      error: "Failed to generate export",
    };
  }
}

/**
 * Export with voice information (for use with voice library)
 */
export async function exportWithVoice(
  text: string,
  voiceId: string,
  format: ExportFormat,
): Promise<ExportResult> {
  try {
    // Get voice from library
    const voice = getVoiceById(voiceId);
    
    if (!voice) {
      return { success: false, error: "Voice not found" };
    }

    // Use provider voice ID for Twilio/Polly voices
    const providerVoiceId = voice.providerVoiceId;
    const language = voice.languageCode;

    let content: string;

    switch (format) {
      case "twiml":
        content = generateTwiML(text, providerVoiceId, language);
        break;
      case "studio-json":
        content = generateStudioJSON(text, providerVoiceId, language);
        break;
      case "node-snippet":
        content = generateNodeSnippet(text, providerVoiceId, language);
        break;
      case "python-snippet":
        content = generatePythonSnippet(text, providerVoiceId, language);
        break;
      default:
        return { success: false, error: "Invalid export format" };
    }

    return {
      success: true,
      content,
    };
  } catch (error) {
    console.error("Export error:", error);
    return {
      success: false,
      error: "Failed to generate export",
    };
  }
}

